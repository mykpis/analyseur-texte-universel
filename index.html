<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyseur de Texte Intelligent - Version Am√©lior√©e</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #667eea;
        }
        .header h1 {
            color: #333;
            margin: 0;
            font-size: 2.5em;
        }
        .header p {
            color: #666;
            margin: 10px 0;
            font-size: 1.1em;
        }
        .version-info {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #28a745;
        }
        
        /* Mode Selector */
        .mode-selector {
            margin: 30px 0;
        }
        .mode-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .mode-card {
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            background: #f8f9fa;
        }
        .mode-card:hover {
            border-color: #667eea;
            background: #f0f4ff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }
        .mode-card.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            transform: scale(1.02);
        }
        .mode-card h4 {
            margin: 0 0 10px 0;
            font-size: 1.3em;
        }
        .mode-card p {
            margin: 0;
            opacity: 0.8;
        }

        /* Configuration Panels */
        .config-panel {
            display: none;
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
            border-left: 5px solid #667eea;
        }
        .config-panel.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* File Upload */
        .file-upload {
            margin: 15px 0;
            padding: 15px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            text-align: center;
            transition: border-color 0.3s;
        }
        .file-upload:hover {
            border-color: #667eea;
        }
        .file-upload input[type="file"] {
            margin: 10px 0;
        }
        .file-uploaded {
            border-color: #28a745;
            background-color: #d4edda;
        }

        /* Parameters */
        .parameters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .param-group {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        .param-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }
        .param-group input, .param-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        /* Status and Results */
        .status {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: 500;
        }
        .status.info { background-color: #d1ecf1; color: #0c5460; border-left: 4px solid #17a2b8; }
        .status.success { background-color: #d4edda; color: #155724; border-left: 4px solid #28a745; }
        .status.warning { background-color: #fff3cd; color: #856404; border-left: 4px solid #ffc107; }
        .status.error { background-color: #f8d7da; color: #721c24; border-left: 4px solid #dc3545; }

        .button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 10px 5px;
            transition: all 0.3s;
        }
        .button:hover { 
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        .button:disabled { 
            background: #6c757d; 
            cursor: not-allowed; 
            transform: none;
            box-shadow: none;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border-left: 4px solid #667eea;
            transition: transform 0.3s;
        }
        .stat-card:hover {
            transform: scale(1.05);
        }
        .stat-number {
            font-size: 28px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .examples, .results-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            max-height: 500px;
            overflow-y: auto;
        }
        .example-item {
            background: white;
            margin: 15px 0;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #28a745;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .table-container {
            max-height: 600px;
            overflow: auto;
            border: 1px solid #ddd;
            border-radius: 12px;
            margin: 20px 0;
            background: white;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 12px 8px;
            text-align: left;
            max-width: 300px;
            word-wrap: break-word;
        }
        .data-table th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .data-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        .data-table tr:hover {
            background-color: #e3f2fd;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }
        .copy-button {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }
        .copy-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
        }

        .hidden { display: none !important; }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .algorithm-info {
            background: #f0f8ff;
            border: 1px solid #b3d9ff;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }
        .algorithm-info h4 {
            color: #0066cc;
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† Analyseur de Texte Intelligent</h1>
            <p>Analyse multi-concepts avec traduction IA et matching avec liste de r√©f√©rence</p>
            <div class="version-info">
                <strong>üéØ Version Am√©lior√©e</strong> - Sans dictionnaire interne : L'IA traduit en temps r√©el et matche avec votre liste de r√©f√©rence. D√©tection de plusieurs concepts par phrase avec colonne "Traduction IA" pour les non-identifi√©s.
            </div>
            <input type="text" id="projectTitle" placeholder="Nom de votre projet (ex: Analyse satisfaction client)" 
                   style="width: 400px; padding: 10px; border: 2px solid #667eea; border-radius: 8px; font-size: 16px; text-align: center;">
        </div>

        <!-- Mode Selector -->
        <div class="mode-selector">
            <h3>üéØ Choisissez votre m√©thode de traitement</h3>
            <div class="mode-cards">
                <div class="mode-card" data-mode="intelligent">
                    <h4>üß† Analyse Multi-Concepts</h4>
                    <p>D√©tection de tous les concepts dans chaque phrase avec traduction IA intelligente</p>
                </div>
                <div class="mode-card" data-mode="hybrid">
                    <h4>üîó Mode Hybride</h4>
                    <p>Combine votre dictionnaire personnel + analyse multi-concepts IA</p>
                </div>
                <div class="mode-card" data-mode="advanced">
                    <h4>‚öôÔ∏è Analyse Personnalis√©e</h4>
                    <p>Param√®tres avanc√©s pour un contr√¥le total de l'analyse</p>
                </div>
            </div>
        </div>

        <!-- Configuration Panels -->
        
        <!-- Mode Intelligent -->
        <div id="config-intelligent" class="config-panel">
            <h3>üß† Configuration - Analyse Multi-Concepts</h3>
            <div class="algorithm-info">
                <h4>Nouvelle approche intelligente :</h4>
                <p>‚Ä¢ <strong>D√©tection multi-concepts</strong> : Identifie tous les concepts dans chaque phrase</p>
                <p>‚Ä¢ <strong>Traduction IA contextuelle</strong> : Sans dictionnaire pr√©d√©fini, traduction adaptative</p>
                <p>‚Ä¢ <strong>Matching intelligent</strong> : Compare avec votre liste de r√©f√©rence</p>
                <p>‚Ä¢ <strong>Colonne "Traduction IA"</strong> : Pour les concepts non identifi√©s dans la liste</p>
            </div>
            <div class="file-upload" id="upload-intelligent-main">
                <strong>üìÑ Fichier principal (r√©ponses √† analyser)</strong>
                <input type="file" id="mainFile-intelligent" accept=".xlsx,.xls" />
                <p>Fichier contenant les r√©ponses textuelles √† analyser</p>
            </div>
            <div class="file-upload" id="upload-intelligent-ref">
                <strong>üìã Fichier de r√©f√©rence (cat√©gories cibles)</strong>
                <input type="file" id="refFile-intelligent" accept=".xlsx,.xls" />
                <p>Fichier contenant la liste des cat√©gories standardis√©es</p>
            </div>
        </div>

        <!-- Mode Hybride -->
        <div id="config-hybrid" class="config-panel">
            <h3>üîó Configuration - Mode Hybride</h3>
            <div class="algorithm-info">
                <h4>Fonctionnement hybride :</h4>
                <p>‚Ä¢ <strong>Priorit√© au dictionnaire</strong> : Recherche d'abord dans votre dictionnaire</p>
                <p>‚Ä¢ <strong>Compl√©ment IA</strong> : Analyse intelligente pour les termes non trouv√©s</p>
                <p>‚Ä¢ <strong>Multi-concepts</strong> : D√©tection de plusieurs id√©es par phrase</p>
                <p>‚Ä¢ <strong>Traduction des r√©sidus</strong> : Colonne IA pour ce qui n'est pas match√©</p>
            </div>
            <div class="file-upload" id="upload-hybrid-main">
                <strong>üìÑ Fichier principal (r√©ponses √† analyser)</strong>
                <input type="file" id="mainFile-hybrid" accept=".xlsx,.xls" />
            </div>
            <div class="file-upload" id="upload-hybrid-ref">
                <strong>üìã Fichier de r√©f√©rence (cat√©gories cibles)</strong>
                <input type="file" id="refFile-hybrid" accept=".xlsx,.xls" />
            </div>
            <div class="file-upload" id="upload-hybrid-dict">
                <strong>üìö Fichier de correspondances (votre dictionnaire)</strong>
                <input type="file" id="dictFile-hybrid" accept=".xlsx,.xls" />
                <p>Format: Colonne A = Termes source, Colonne B = Cat√©gories cibles</p>
            </div>
        </div>

        <!-- Mode Avanc√© -->
        <div id="config-advanced" class="config-panel">
            <h3>‚öôÔ∏è Configuration - Analyse Personnalis√©e</h3>
            <div class="file-upload" id="upload-advanced-main">
                <strong>üìÑ Fichier principal (r√©ponses √† analyser)</strong>
                <input type="file" id="mainFile-advanced" accept=".xlsx,.xls" />
            </div>
            <div class="file-upload" id="upload-advanced-ref">
                <strong>üìã Fichier de r√©f√©rence (cat√©gories cibles)</strong>
                <input type="file" id="refFile-advanced" accept=".xlsx,.xls" />
            </div>
            <div class="parameters">
                <div class="param-group">
                    <label>Seuil de correspondance (%)</label>
                    <input type="range" id="similarity-threshold" min="10" max="80" value="40" 
                           oninput="document.getElementById('similarity-value').textContent = this.value + '%'">
                    <span id="similarity-value">40%</span>
                    <small>Plus bas = plus de correspondances</small>
                </div>
                <div class="param-group">
                    <label>Concepts max par r√©ponse</label>
                    <select id="max-concepts">
                        <option value="3" selected>3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                    </select>
                </div>
                <div class="param-group">
                    <label>Longueur min des mots</label>
                    <input type="number" id="min-word-length" value="3" min="2" max="6">
                    <small>Mots plus courts ignor√©s</small>
                </div>
                <div class="param-group">
                    <label>Mode d'analyse</label>
                    <select id="analysis-mode">
                        <option value="comprehensive" selected>Complet (tous concepts)</option>
                        <option value="prioritized">Prioris√© (concepts principaux)</option>
                        <option value="balanced">√âquilibr√© (mix)</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Processing Button -->
        <div style="text-align: center; margin: 30px 0;">
            <button id="processBtn" class="button" onclick="lancerAnalyse()" disabled>
                üöÄ Lancer l'Analyse Multi-Concepts
            </button>
        </div>

        <!-- Status -->
        <div id="status" class="status info hidden">
            Pr√™t √† analyser...
        </div>

        <!-- Progress Bar -->
        <div id="progressContainer" class="hidden">
            <h4>Progression de l'analyse</h4>
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill"></div>
            </div>
            <p id="progressText">Initialisation...</p>
        </div>

        <!-- Results -->
        <div id="statsContainer" class="hidden">
            <h3>üìä Statistiques de l'Analyse</h3>
            <div class="stats" id="stats"></div>
        </div>

        <div id="examplesContainer" class="hidden">
            <h3>üìù Exemples d'Analyse Multi-Concepts</h3>
            <div class="examples" id="examples"></div>
        </div>

        <div id="downloadContainer" class="hidden">
            <h3>üíæ R√©sultats de l'Analyse</h3>
            <div class="action-buttons" id="downloadLinks"></div>
            <div id="tableContainer"></div>
        </div>
    </div>

    <script>
        // Variables globales
        let currentMode = null;
        let filesData = {
            main: null,
            reference: null,
            dictionary: null
        };
        let processedData = null;

        // Classe principale pour l'analyse multi-concepts intelligente
        class IntelligentMultiConceptAnalyzer {
            constructor() {
                // Mots de liaison √† ignorer
                this.stopWords = new Set([
                    'le', 'la', 'les', 'de', 'du', 'des', 'et', 'ou', 'dans', 'pour', 'avec',
                    'sans', 'sur', 'par', 'en', 'un', 'une', 'ce', 'cette', 'son', 'sa', 'ses',
                    'mon', 'ma', 'mes', 'ton', 'ta', 'tes', 'leur', 'leurs', 'notre', 'nos',
                    'votre', 'vos', 'qui', 'que', 'dont', 'o√π', 'il', 'elle', 'ils', 'elles',
                    'je', 'tu', 'nous', 'vous', 'me', 'te', 'se', 'lui', 'eux', 'moi', 'toi',
                    'est', 'sont', '√©tait', '√©taient', 'sera', 'seront', 'avoir', '√™tre',
                    'tr√®s', 'plus', 'moins', 'bien', 'mal', 'pas', 'non', 'oui', 'si', 'ne',
                    'au', 'aux', '√†', '√ßa', 'cela', 'comme', 'donc', 'mais', 'car', 'puis'
                ]);
            }

            // Identifier les groupes de concepts dans une phrase
            identifyConcepts(text) {
                if (!text || typeof text !== 'string') return [];
                
                const cleanText = text.toLowerCase()
                    .replace(/[^\w\s√†√°√¢√§√ß√©√®√™√´√Ø√≠√Æ√¥√∂√π√∫√ª√º√ø]/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();

                // Diviser en segments potentiels (par connecteurs)
                const segments = this.segmentText(cleanText);
                
                // Analyser chaque segment pour extraire les concepts
                const concepts = [];
                segments.forEach(segment => {
                    const concept = this.extractConceptFromSegment(segment);
                    if (concept && concept.length > 0) {
                        concepts.push(concept);
                    }
                });

                return concepts;
            }

            // Segmenter le texte en groupes conceptuels
            segmentText(text) {
                // Connecteurs qui indiquent souvent un nouveau concept
                const connectors = ['et', 'aussi', 'ainsi que', 'de plus', 'en plus', 'par ailleurs', '√©galement', 'puis', 'ensuite'];
                
                let segments = [text];
                
                // Diviser par connecteurs
                connectors.forEach(connector => {
                    const newSegments = [];
                    segments.forEach(segment => {
                        const parts = segment.split(new RegExp(`\\b${connector}\\b`, 'gi'));
                        parts.forEach((part, index) => {
                            if (part.trim()) {
                                newSegments.push(part.trim());
                            }
                        });
                    });
                    segments = newSegments;
                });

                // Diviser par ponctuation forte
                const finalSegments = [];
                segments.forEach(segment => {
                    const parts = segment.split(/[;,]/);
                    parts.forEach(part => {
                        if (part.trim() && part.trim().length > 3) {
                            finalSegments.push(part.trim());
                        }
                    });
                });

                return finalSegments.length > 0 ? finalSegments : [text];
            }

            // Extraire le concept principal d'un segment
            extractConceptFromSegment(segment) {
                const words = segment.split(/\s+/)
                    .filter(word => word.length > 2 && !this.stopWords.has(word));

                if (words.length === 0) return '';

                // Regrouper les mots connexes pour former un concept coh√©rent
                return this.buildConcept(words, segment);
            }

            // Construire un concept coh√©rent √† partir des mots
            buildConcept(words, originalSegment) {
                // Chercher des termes cl√©s sp√©cifiques
                const keyTerms = this.identifyKeyTerms(words, originalSegment);
                
                if (keyTerms.length > 0) {
                    return keyTerms.join(' ');
                }

                // Sinon, prendre les mots les plus significatifs
                return words.slice(0, Math.min(4, words.length)).join(' ');
            }

            // Identifier les termes cl√©s dans un contexte
            identifyKeyTerms(words, context) {
                const keyTermPatterns = [
                    // Service et accueil
                    { pattern: ['accueil'], concept: 'accueil' },
                    { pattern: ['service'], concept: 'service' },
                    { pattern: ['comportement', 'agents'], concept: 'comportement des agents' },
                    { pattern: ['traitement', 'agents'], concept: 'traitement des agents' },
                    
                    // Rapidit√© et temps
                    { pattern: ['rapidit√©'], concept: 'rapidit√©' },
                    { pattern: ['rapide'], concept: 'rapidit√©' },
                    { pattern: ['lenteur'], concept: 'lenteur' },
                    { pattern: ['lent'], concept: 'lenteur' },
                    { pattern: ['temps'], concept: 'temps de traitement' },
                    { pattern: ['d√©lai'], concept: 'd√©lai' },
                    
                    // Traitement et processus
                    { pattern: ['traitement', 'dossier'], concept: 'traitement des dossiers' },
                    { pattern: ['traitement', 'cr√©dit'], concept: 'traitement des cr√©dits' },
                    { pattern: ['processus'], concept: 'processus' },
                    { pattern: ['proc√©dure'], concept: 'proc√©dures' },
                    
                    // Montant et finance
                    { pattern: ['montant'], concept: 'montant' },
                    { pattern: ['cr√©dit'], concept: 'cr√©dit' },
                    { pattern: ['frais'], concept: 'frais' },
                    { pattern: ['taux'], concept: 'taux' },
                    { pattern: ['int√©r√™t'], concept: 'taux d\'int√©r√™t' },
                    
                    // Documents et formalit√©s
                    { pattern: ['documents'], concept: 'documents' },
                    { pattern: ['papiers'], concept: 'documents' },
                    { pattern: ['signature'], concept: 'signature' },
                    { pattern: ['formalit√©s'], concept: 'formalit√©s' },
                    
                    // Satisfaction
                    { pattern: ['satisfait'], concept: 'satisfaction' },
                    { pattern: ['content'], concept: 'satisfaction' },
                    { pattern: ['bon'], concept: 'satisfaction' },
                    { pattern: ['bien'], concept: 'satisfaction' },
                    { pattern: ['excellent'], concept: 'tr√®s satisfait' },
                    { pattern: ['parfait'], concept: 'parfait' },
                    { pattern: ['mauvais'], concept: 'insatisfaction' },
                    { pattern: ['nul'], concept: 'tr√®s insatisfait' }
                ];

                const identifiedTerms = [];
                const contextLower = context.toLowerCase();

                keyTermPatterns.forEach(({ pattern, concept }) => {
                    const hasAllTerms = pattern.every(term => 
                        words.some(word => word.includes(term)) || contextLower.includes(term)
                    );
                    
                    if (hasAllTerms) {
                        identifiedTerms.push(concept);
                    }
                });

                return [...new Set(identifiedTerms)]; // Supprimer les doublons
            }

            // Traduire compl√®tement en fran√ßais
            translateConcept(concept) {
                if (!concept || concept.trim() === '') return '';
                
                // Dictionnaire complet darija ‚Üí fran√ßais
                const darijaToFrench = {
                    // Mots courants
                    'mossa3ada': 'aide',
                    'mosa3ada': 'aide',
                    'ta3awon': 'assistance',
                    'ta3aoun': 'coop√©ration',
                    'dyalhom': 'leur',
                    'dyali': 'mon',
                    'dyalk': 'ton',
                    'souhola': 'facilit√©',
                    'sahl': 'facile',
                    'sahla': 'facile',
                    'ijra2at': 'proc√©dures',
                    'ijraat': 'proc√©dures',
                    'jira2at': 'proc√©dures',
                    
                    // Service et qualit√©
                    'khedma': 'service',
                    'khdema': 'service',
                    'khidma': 'service',
                    'ta3aml': 'traitement',
                    'ta3amul': 'comportement',
                    'mou3amala': 'traitement',
                    'mo3amala': 'traitement',
                    'istiqbal': 'accueil',
                    'marr7aba': 'accueil',
                    
                    // Satisfaction/Qualit√©
                    'zwin': 'bon',
                    'zwina': 'bonne',
                    'mezyan': 'bon',
                    'mezyana': 'bonne',
                    'mliha': 'bien',
                    'mli7': 'bien',
                    'khayb': 'mauvais',
                    'khayba': 'mauvaise',
                    'mabsout': 'satisfait',
                    'mabsouta': 'satisfaite',
                    'farhan': 'content',
                    'far7ana': 'contente',
                    
                    // Rapidit√© et temps
                    'sari3': 'rapide',
                    'sari3a': 'rapide',
                    'b3ida': 'lent',
                    'b3da': 'lentement',
                    'deghayin': 'rapidement',
                    'fissa': 'vite',
                    'waqt': 'temps',
                    'toul': 'dur√©e',
                    'qsir': 'court',
                    'tawil': 'long',
                    
                    // Argent et montants
                    'flous': 'argent',
                    'dar7am': 'dirham',
                    'darham': 'dirham',
                    'mablagh': 'montant',
                    'thaman': 'prix',
                    'khllas': 'pay√©',
                    'dfa3': 'pay√©',
                    'ma3tawnich': 'ne m\'ont pas donn√©',
                    'ma3tani': 'ne m\'a pas donn√©',
                    'bghit': 'je veux',
                    'bghina': 'nous voulons',
                    
                    // Quantit√©
                    'kaml': 'complet',
                    'kamla': 'compl√®te',
                    'tal3': '√©lev√©',
                    'tal3a': '√©lev√©e',
                    'nzel': 'bas',
                    'nzela': 'basse',
                    'bezzaf': 'beaucoup',
                    'bzaf': 'beaucoup',
                    'shwiya': 'un peu',
                    'qalil': 'peu',
                    'ktir': 'beaucoup',
                    
                    // Disponibilit√© et acc√®s
                    'mo3amala': 'transaction',
                    'mzyana': 'bonne',
                    'mzyan': 'bon',
                    'istikbal': 'r√©ception',
                    'la9bal': 'acceptation',
                    'lacceptation': 'acceptation',
                    'disponibilit√©': 'disponibilit√©',
                    'disponibiliter': 'disponibilit√©',
                    'mo3amala': 'traitement',
                    
                    // Cr√©dit et finance
                    'cr√©dit': 'cr√©dit',
                    'credit': 'cr√©dit',
                    'qard': 'pr√™t',
                    'tamwil': 'financement',
                    'fawa2id': 'int√©r√™ts',
                    'riba': 'int√©r√™t',
                    
                    // N√©gation et connecteurs
                    'mashi': 'pas',
                    'makanch': 'il n\'y avait pas',
                    'makainch': 'il n\'y a pas',
                    'ma3endish': 'je n\'ai pas',
                    '3andi': 'j\'ai',
                    'wakha': 'm√™me si',
                    'walakin': 'mais',
                    'li2anna': 'parce que',
                    
                    // Institutions
                    'bank': 'banque',
                    'banka': 'banque',
                    'societe': 'soci√©t√©',
                    'cherka': 'entreprise',
                    'mo2assasa': 'institution',
                    'ida9a': 'administration',
                    'maktab': 'bureau',
                    
                    // Agents et personnel
                    'agents': 'agents',
                    'agent': 'agent',
                    'mowadaf': 'employ√©',
                    'mowadafa': 'employ√©e',
                    'mowadafin': 'employ√©s',
                    'mas2oul': 'responsable',
                    'mas2oula': 'responsable',
                    
                    // Processus et documents
                    'waraq': 'papier',
                    'awraq': 'papiers',
                    'watha2iq': 'documents',
                    'wathiqa': 'document',
                    'tawqi3': 'signature',
                    'ijra2at': 'proc√©dures',
                    'marahil': '√©tapes',
                    'mar7ala': '√©tape'
                };

                let translatedText = concept.toLowerCase();
                
                // Appliquer les traductions mot par mot
                Object.entries(darijaToFrench).forEach(([darija, french]) => {
                    // Remplacer les mots entiers
                    const regex = new RegExp(`\\b${darija}\\b`, 'gi');
                    translatedText = translatedText.replace(regex, french);
                });
                
                // Nettoyer et standardiser
                translatedText = translatedText
                    .replace(/\s+/g, ' ')
                    .trim()
                    .replace(/^(le|la|les|du|des|de)\s+/i, '') // Enlever articles en d√©but
                    .replace(/\s+(le|la|les|du|des|de)$/i, ''); // Enlever articles en fin

                // Si pas de traduction significative, retourner une interpr√©tation
                if (translatedText === concept.toLowerCase() || translatedText.length < 2) {
                    return this.interpretConcept(concept);
                }

                return this.capitalizeFirst(translatedText);
            }

            // Interpr√©ter un concept non traduit
            interpretConcept(concept) {
                const interpretations = {
                    // Patterns de concepts
                    'comportement': 'comportement du personnel',
                    'agent': 'service des agents',
                    'accueil': 'qualit√© d\'accueil',
                    'rapid': 'rapidit√© du service',
                    'lent': 'lenteur du processus',
                    'temps': 'd√©lai de traitement',
                    'document': 'gestion des documents',
                    'signature': 'processus de signature',
                    'montant': 'montant du cr√©dit',
                    'cr√©dit': 'produit cr√©dit',
                    'banque': 'service bancaire',
                    'satisf': 'niveau de satisfaction',
                    'probl√®me': 'probl√®me rencontr√©'
                };

                const lowerConcept = concept.toLowerCase();
                
                for (const [key, interpretation] of Object.entries(interpretations)) {
                    if (lowerConcept.includes(key)) {
                        return interpretation;
                    }
                }
                
                return concept; // Retourner tel quel si pas d'interpr√©tation
            }

            // Capitaliser la premi√®re lettre
            capitalizeFirst(text) {
                if (!text) return text;
                return text.charAt(0).toUpperCase() + text.slice(1);
            }

            // Matcher un concept avec la liste de r√©f√©rence (am√©lior√©)
            matchWithReference(concept, referenceCategories, threshold = 0.4) {
                if (!concept || !referenceCategories.length) return null;

                // Nettoyer le concept pour la comparaison
                const cleanConcept = concept.toLowerCase().trim();
                
                let bestMatch = null;
                let bestScore = 0;

                referenceCategories.forEach(category => {
                    const cleanCategory = category.toLowerCase().trim();
                    
                    // 1. Correspondance exacte (priorit√© haute)
                    if (cleanConcept === cleanCategory) {
                        bestMatch = {
                            category: category,
                            score: 1.0,
                            matchType: 'exact'
                        };
                        return;
                    }
                    
                    // 2. Correspondance par inclusion (priorit√© moyenne)
                    if (cleanConcept.includes(cleanCategory) || cleanCategory.includes(cleanConcept)) {
                        const score = 0.9;
                        if (score > bestScore) {
                            bestScore = score;
                            bestMatch = {
                                category: category,
                                score: score,
                                matchType: 'inclusion'
                            };
                        }
                    }
                    
                    // 3. Correspondance s√©mantique (priorit√© normale)
                    const semanticScore = this.calculateSemanticSimilarity(cleanConcept, cleanCategory);
                    if (semanticScore > bestScore && semanticScore >= threshold) {
                        bestScore = semanticScore;
                        bestMatch = {
                            category: category,
                            score: semanticScore,
                            matchType: 'semantic'
                        };
                    }
                });

                return bestMatch;
            }

            // Calculer la similarit√© s√©mantique
            calculateSemanticSimilarity(text1, text2) {
                if (!text1 || !text2) return 0;

                const words1 = this.extractKeywords(text1);
                const words2 = this.extractKeywords(text2);
                
                if (words1.length === 0 || words2.length === 0) return 0;

                // Correspondances exactes
                const exactMatches = words1.filter(w1 => 
                    words2.some(w2 => this.normalizeWord(w1) === this.normalizeWord(w2))
                ).length;

                // Correspondances partielles
                let partialMatches = 0;
                words1.forEach(w1 => {
                    words2.forEach(w2 => {
                        if (this.isPartialMatch(w1, w2)) {
                            partialMatches += 0.5;
                        }
                    });
                });

                const totalWords = Math.max(words1.length, words2.length);
                return (exactMatches + partialMatches) / totalWords;
            }

            // Extraire les mots-cl√©s
            extractKeywords(text) {
                if (!text) return [];
                
                return text.toLowerCase()
                    .replace(/[^\w\s]/g, ' ')
                    .split(/\s+/)
                    .filter(word => 
                        word.length > 2 && 
                        !this.stopWords.has(word) &&
                        !this.isNumber(word)
                    );
            }

            // Normaliser un mot
            normalizeWord(word) {
                return word
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '')
                    .replace(/s$/, '')
                    .replace(/x$/, '')
                    .toLowerCase();
            }

            // V√©rifier si c'est un nombre
            isNumber(str) {
                return !isNaN(str) && !isNaN(parseFloat(str));
            }

            // V√©rifier correspondance partielle
            isPartialMatch(word1, word2) {
                if (word1.length < 3 || word2.length < 3) return false;
                
                const norm1 = this.normalizeWord(word1);
                const norm2 = this.normalizeWord(word2);
                
                // Si un mot contient l'autre
                if (norm1.includes(norm2) || norm2.includes(norm1)) return true;
                
                // Distance de Levenshtein
                const distance = this.levenshteinDistance(norm1, norm2);
                const maxLength = Math.max(norm1.length, norm2.length);
                const similarity = 1 - (distance / maxLength);
                
                return similarity >= 0.7;
            }

            // Distance de Levenshtein
            levenshteinDistance(str1, str2) {
                const matrix = Array(str2.length + 1).fill().map(() => Array(str1.length + 1).fill(0));
                
                for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
                for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
                
                for (let j = 1; j <= str2.length; j++) {
                    for (let i = 1; i <= str1.length; i++) {
                        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                        matrix[j][i] = Math.min(
                            matrix[j - 1][i] + 1,
                            matrix[j][i - 1] + 1,
                            matrix[j - 1][i - 1] + cost
                        );
                    }
                }
                
                return matrix[str2.length][str1.length];
            }

            // Analyser une r√©ponse compl√®te avec traduction fran√ßaise et matching intelligent
            analyzeResponse(responseText, referenceCategories, maxConcepts = 3, threshold = 0.4) {
                const concepts = this.identifyConcepts(responseText);
                const results = {
                    matchedCategories: [],
                    unmatchedConcepts: [],
                    translatedText: ''
                };

                const processedConcepts = [];

                concepts.forEach(concept => {
                    if (results.matchedCategories.length >= maxConcepts) return;
                    
                    // 1. Traduire le concept en fran√ßais
                    const frenchConcept = this.translateConcept(concept);
                    
                    // 2. Essayer de matcher avec la liste de r√©f√©rence (concept original)
                    let match = this.matchWithReference(concept, referenceCategories, threshold);
                    
                    // 3. Si pas de match, essayer avec la traduction fran√ßaise
                    if (!match && frenchConcept !== concept) {
                        match = this.matchWithReference(frenchConcept, referenceCategories, threshold);
                    }
                    
                    // 4. Traitement du r√©sultat
                    if (match) {
                        // Match trouv√© dans la liste de r√©f√©rence
                        if (!results.matchedCategories.includes(match.category)) {
                            results.matchedCategories.push(match.category);
                        }
                    } else {
                        // Pas de match : garder la traduction fran√ßaise
                        if (frenchConcept && frenchConcept.trim() !== '') {
                            // V√©rifier que ce n'est pas un doublon s√©mantique
                            const isDuplicate = processedConcepts.some(processed => 
                                this.calculateSemanticSimilarity(frenchConcept, processed) > 0.8
                            );
                            
                            if (!isDuplicate) {
                                results.unmatchedConcepts.push(frenchConcept);
                                processedConcepts.push(frenchConcept);
                            }
                        }
                    }
                });

                // Cr√©er la traduction IA finale
                if (results.unmatchedConcepts.length > 0) {
                    results.translatedText = results.unmatchedConcepts
                        .filter(concept => concept && concept.trim() !== '')
                        .join(' | '); // S√©parer par | pour clart√©
                }

                return results;
            }
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            updateProjectTitle();
        });

        function setupEventListeners() {
            // Mode selection
            document.querySelectorAll('.mode-card').forEach(card => {
                card.addEventListener('click', function() {
                    selectMode(this.dataset.mode);
                });
            });

            // File uploads
            const modes = ['intelligent', 'hybrid', 'advanced'];
            modes.forEach(mode => {
                const mainFileInput = document.getElementById(`mainFile-${mode}`);
                const refFileInput = document.getElementById(`refFile-${mode}`);
                
                if (mainFileInput) {
                    mainFileInput.addEventListener('change', function(e) {
                        handleFileUpload(e, 'main', mode);
                    });
                }
                
                if (refFileInput) {
                    refFileInput.addEventListener('change', function(e) {
                        handleFileUpload(e, 'reference', mode);
                    });
                }
            });

            // Dictionnaire pour mode hybride
            const dictFileInput = document.getElementById('dictFile-hybrid');
            if (dictFileInput) {
                dictFileInput.addEventListener('change', function(e) {
                    handleFileUpload(e, 'dictionary', 'hybrid');
                });
            }

            document.getElementById('projectTitle').addEventListener('input', updateProjectTitle);
        }

        function selectMode(mode) {
            currentMode = mode;
            
            document.querySelectorAll('.mode-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('selected');
            
            document.querySelectorAll('.config-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById(`config-${mode}`).classList.add('active');
            
            resetFilesAndButton();
            updateStatus('Mode s√©lectionn√©: ' + getModeDisplayName(mode), 'info');
        }

        function getModeDisplayName(mode) {
            const names = {
                'intelligent': 'Analyse Multi-Concepts',
                'hybrid': 'Mode Hybride',
                'advanced': 'Analyse Personnalis√©e'
            };
            return names[mode] || mode;
        }

        function handleFileUpload(event, fileType, mode) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                filesData[fileType] = new Uint8Array(e.target.result);
                
                const uploadDiv = event.target.closest('.file-upload');
                uploadDiv.classList.add('file-uploaded');
                
                checkReadyToProcess();
            };
            reader.readAsArrayBuffer(file);
        }

        function resetFilesAndButton() {
            filesData = { main: null, reference: null, dictionary: null };
            document.querySelectorAll('.file-upload').forEach(div => {
                div.classList.remove('file-uploaded');
            });
            document.getElementById('processBtn').disabled = true;
        }

        function checkReadyToProcess() {
            const processBtn = document.getElementById('processBtn');
            let ready = false;

            switch(currentMode) {
                case 'intelligent':
                case 'advanced':
                    ready = filesData.main && filesData.reference;
                    break;
                case 'hybrid':
                    ready = filesData.main && filesData.reference && filesData.dictionary;
                    break;
            }

            processBtn.disabled = !ready;
            
            if (ready) {
                updateStatus('‚úÖ Fichiers charg√©s! Pr√™t pour l\'analyse multi-concepts.', 'success');
            }
        }

        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.className = `status ${type}`;
            statusDiv.innerHTML = message;
            statusDiv.classList.remove('hidden');
        }

        function updateProgress(percent, text) {
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            progressContainer.classList.remove('hidden');
            progressFill.style.width = percent + '%';
            progressText.textContent = text;
        }

        function updateProjectTitle() {
            const title = document.getElementById('projectTitle').value;
            if (title) {
                document.querySelector('.header h1').textContent = `üß† ${title}`;
            } else {
                document.querySelector('.header h1').textContent = 'üß† Analyseur de Texte Intelligent';
            }
        }

        // Fonction principale d'analyse
        async function lancerAnalyse() {
            if (!currentMode || !filesData.main || !filesData.reference) {
                updateStatus('‚ùå Veuillez s√©lectionner un mode et charger les fichiers requis.', 'error');
                return;
            }

            try {
                updateStatus('üß† D√©marrage de l\'analyse multi-concepts...', 'info');
                updateProgress(0, 'Initialisation...');

                // Lire les fichiers
                updateProgress(10, 'Lecture des fichiers...');
                const mainData = await readExcelFile(filesData.main);
                const refData = await readExcelFile(filesData.reference);

                updateProgress(20, 'Analyse de la structure des donn√©es...');
                
                // D√©tecter les colonnes
                const mainColumns = Object.keys(mainData[0]);
                const responseColumn = detectResponseColumn(mainData[0]);
                const idColumn = mainColumns[0];
                
                // Extraire les cat√©gories de r√©f√©rence
                const refColumns = Object.keys(refData[0]);
                const categoryColumn = refColumns.find(col => 
                    col.toLowerCase().includes('raison') || 
                    col.toLowerCase().includes('cat√©gorie') ||
                    col.toLowerCase().includes('motif') ||
                    col.toLowerCase().includes('satisfaction') ||
                    col.toLowerCase().includes('aspect')
                ) || refColumns[0];
                
                const referenceCategories = refData.map(row => row[categoryColumn])
                    .filter(cat => cat && cat.toString().trim())
                    .map(cat => cat.toString().trim());

                const uniqueCategories = [...new Set(referenceCategories)];
                updateProgress(30, `${uniqueCategories.length} cat√©gories de r√©f√©rence d√©tect√©es...`);

                let processedResults = [];

                // Traitement selon le mode
                switch(currentMode) {
                    case 'intelligent':
                        processedResults = await processWithIntelligentAnalysis(
                            mainData, uniqueCategories, responseColumn, idColumn
                        );
                        break;
                        
                    case 'hybrid':
                        const dictData = await readExcelFile(filesData.dictionary);
                        processedResults = await processWithHybridAnalysis(
                            mainData, uniqueCategories, dictData, responseColumn, idColumn
                        );
                        break;
                        
                    case 'advanced':
                        processedResults = await processWithAdvancedAnalysis(
                            mainData, uniqueCategories, responseColumn, idColumn
                        );
                        break;
                }

                updateProgress(90, 'Finalisation des r√©sultats...');
                await finalizeResults(processedResults, mainData, responseColumn);
                updateProgress(100, 'Analyse multi-concepts termin√©e!');

            } catch (error) {
                updateStatus(`‚ùå Erreur: ${error.message}`, 'error');
                console.error('Erreur d\'analyse:', error);
            }
        }

        async function readExcelFile(fileData) {
            const workbook = XLSX.read(fileData);
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            return XLSX.utils.sheet_to_json(worksheet);
        }

        function detectResponseColumn(firstRow) {
            const columns = Object.keys(firstRow);
            
            const keywords = ['r√©ponse', 'motif', 'raison', 'commentaire', 'quels', 'pourquoi', 'insatisfait', 'satisfait', 'texte', 'avis'];
            
            for (const keyword of keywords) {
                const found = columns.find(col => 
                    col.toLowerCase().includes(keyword)
                );
                if (found) return found;
            }
            
            return columns[1] || columns[0];
        }

        // Analyse intelligente sans dictionnaire
        async function processWithIntelligentAnalysis(mainData, referenceCategories, responseColumn, idColumn) {
            const analyzer = new IntelligentMultiConceptAnalyzer();
            const results = [];
            
            updateProgress(40, 'Analyse multi-concepts en cours...');
            
            mainData.forEach((row, index) => {
                const response = row[responseColumn];
                const processedRow = { ...row };
                
                // Initialiser les colonnes de r√©sultats
                processedRow['Cat√©gorie 1'] = '';
                processedRow['Cat√©gorie 2'] = '';
                processedRow['Cat√©gorie 3'] = '';
                processedRow['Traduction IA'] = '';
                
                if (response && response.toString().trim() !== '') {
                    const analysis = analyzer.analyzeResponse(response, referenceCategories, 3, 0.4);
                    
                    // Remplir les cat√©gories match√©es
                    analysis.matchedCategories.forEach((category, i) => {
                        if (i < 3) {
                            processedRow[`Cat√©gorie ${i + 1}`] = category;
                        }
                    });
                    
                    // Remplir la traduction IA
                    processedRow['Traduction IA'] = analysis.translatedText || '';
                    
                    // Si aucune correspondance trouv√©e
                    if (analysis.matchedCategories.length === 0 && !analysis.translatedText) {
                        processedRow['Traduction IA'] = 'R√©ponse non analysable';
                    }
                } else {
                    processedRow['Traduction IA'] = 'R√©ponse vide';
                }
                
                results.push(processedRow);
                
                if (index % 50 === 0) {
                    updateProgress(40 + (index / mainData.length) * 40, `Analyse: ${index + 1}/${mainData.length}`);
                }
            });
            
            return results;
        }

        // Analyse hybride avec dictionnaire
        async function processWithHybridAnalysis(mainData, referenceCategories, dictData, responseColumn, idColumn) {
            const analyzer = new IntelligentMultiConceptAnalyzer();
            const results = [];
            
            updateProgress(40, 'Chargement du dictionnaire...');
            
            // Charger le dictionnaire
            const customDict = {};
            const dictColumns = Object.keys(dictData[0]);
            const sourceCol = dictColumns[0];
            const targetCol = dictColumns[1];
            
            dictData.forEach(row => {
                const source = row[sourceCol];
                const target = row[targetCol];
                if (source && target) {
                    customDict[source.toString().toLowerCase().trim()] = target.toString().trim();
                }
            });
            
            updateProgress(50, 'Analyse hybride en cours...');
            
            mainData.forEach((row, index) => {
                const response = row[responseColumn];
                const processedRow = { ...row };
                
                processedRow['Cat√©gorie 1'] = '';
                processedRow['Cat√©gorie 2'] = '';
                processedRow['Cat√©gorie 3'] = '';
                processedRow['Traduction IA'] = '';
                processedRow['M√©thode'] = '';
                
                if (response && response.toString().trim() !== '') {
                    // 1. Recherche dans le dictionnaire d'abord
                    const dictMatches = findDictionaryMatches(response, customDict);
                    
                    if (dictMatches.length > 0) {
                        dictMatches.slice(0, 3).forEach((category, i) => {
                            processedRow[`Cat√©gorie ${i + 1}`] = category;
                        });
                        processedRow['M√©thode'] = 'Dictionnaire';
                    } else {
                        // 2. Analyse intelligente
                        const analysis = analyzer.analyzeResponse(response, referenceCategories, 3, 0.4);
                        
                        analysis.matchedCategories.forEach((category, i) => {
                            if (i < 3) {
                                processedRow[`Cat√©gorie ${i + 1}`] = category;
                            }
                        });
                        
                        processedRow['Traduction IA'] = analysis.translatedText || '';
                        processedRow['M√©thode'] = analysis.matchedCategories.length > 0 ? 'IA' : 'Non identifi√©';
                    }
                }
                
                results.push(processedRow);
                
                if (index % 50 === 0) {
                    updateProgress(50 + (index / mainData.length) * 35, `Traitement: ${index + 1}/${mainData.length}`);
                }
            });
            
            return results;
        }

        // Analyse avanc√©e avec param√®tres
        async function processWithAdvancedAnalysis(mainData, referenceCategories, responseColumn, idColumn) {
            const analyzer = new IntelligentMultiConceptAnalyzer();
            const results = [];
            
            // R√©cup√©rer les param√®tres
            const threshold = parseFloat(document.getElementById('similarity-threshold').value) / 100;
            const maxConcepts = parseInt(document.getElementById('max-concepts').value);
            const analysisMode = document.getElementById('analysis-mode').value;
            
            updateProgress(40, `Analyse personnalis√©e (seuil: ${Math.round(threshold*100)}%)...`);
            
            mainData.forEach((row, index) => {
                const response = row[responseColumn];
                const processedRow = { ...row };
                
                // Initialiser les colonnes dynamiquement
                for (let i = 1; i <= maxConcepts; i++) {
                    processedRow[`Cat√©gorie ${i}`] = '';
                }
                processedRow['Traduction IA'] = '';
                processedRow['Mode d\'analyse'] = analysisMode;
                
                if (response && response.toString().trim() !== '') {
                    const analysis = analyzer.analyzeResponse(response, referenceCategories, maxConcepts, threshold);
                    
                    analysis.matchedCategories.forEach((category, i) => {
                        if (i < maxConcepts) {
                            processedRow[`Cat√©gorie ${i + 1}`] = category;
                        }
                    });
                    
                    processedRow['Traduction IA'] = analysis.translatedText || '';
                }
                
                results.push(processedRow);
                
                if (index % 50 === 0) {
                    updateProgress(40 + (index / mainData.length) * 40, `Analyse: ${index + 1}/${mainData.length}`);
                }
            });
            
            return results;
        }

        function findDictionaryMatches(response, customDict) {
            const responseText = response.toString().toLowerCase();
            const matches = [];
            
            for (const [keyword, category] of Object.entries(customDict)) {
                if (responseText.includes(keyword.toLowerCase())) {
                    if (!matches.includes(category)) {
                        matches.push(category);
                    }
                }
            }
            
            return matches;
        }

        // Finalisation des r√©sultats
        async function finalizeResults(processedResults, originalData, responseColumn) {
            processedData = processedResults;
            
            const stats = calculateStats(processedResults, responseColumn);
            displayStats(stats);
            
            const examples = generateExamples(processedResults, responseColumn, 15);
            displayExamples(examples);
            
            setupDownloadInterface();
            
            updateStatus('‚úÖ Analyse multi-concepts termin√©e avec succ√®s!', 'success');
        }

        function calculateStats(data, responseColumn) {
            const stats = {
                total: data.length,
                processed: 0,
                empty: 0,
                withCategories: 0,
                withTranslation: 0,
                multiConcepts: 0
            };
            
            data.forEach(row => {
                const response = row[responseColumn];
                if (!response || response.toString().trim() === '') {
                    stats.empty++;
                } else {
                    stats.processed++;
                    
                    const categoriesCount = Object.keys(row).filter(key => 
                        key.startsWith('Cat√©gorie') && row[key] && row[key] !== ''
                    ).length;
                    
                    if (categoriesCount > 0) {
                        stats.withCategories++;
                        if (categoriesCount > 1) {
                            stats.multiConcepts++;
                        }
                    }
                    
                    if (row['Traduction IA'] && row['Traduction IA'] !== '') {
                        stats.withTranslation++;
                    }
                }
            });
            
            return stats;
        }

        function displayStats(stats) {
            const statsContainer = document.getElementById('statsContainer');
            const statsDiv = document.getElementById('stats');
            
            const successRate = stats.processed > 0 ? Math.round((stats.withCategories / stats.processed) * 100) : 0;
            const multiConceptRate = stats.processed > 0 ? Math.round((stats.multiConcepts / stats.processed) * 100) : 0;
            
            statsDiv.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${stats.total}</div>
                    <div>Total lignes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.processed}</div>
                    <div>R√©ponses analys√©es</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.withCategories}</div>
                    <div>Correspondances trouv√©es</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.multiConcepts}</div>
                    <div>Multi-concepts d√©tect√©s</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.withTranslation}</div>
                    <div>Traductions IA</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${successRate}%</div>
                    <div>Taux de matching</div>
                </div>
            `;
            
            statsContainer.classList.remove('hidden');
        }

        function generateExamples(data, responseColumn, count) {
            const examples = [];
            const processedData = data.filter(row => 
                row[responseColumn] && row[responseColumn].toString().trim() !== ''
            );
            
            for (let i = 0; i < Math.min(count, processedData.length); i++) {
                const row = processedData[i];
                const categories = [];
                
                for (let j = 1; j <= 6; j++) {
                    const cat = row[`Cat√©gorie ${j}`];
                    if (cat && cat !== '') {
                        categories.push(cat);
                    }
                }
                
                examples.push({
                    id: Object.values(row)[0],
                    response: row[responseColumn],
                    categories: categories,
                    translation: row['Traduction IA'] || ''
                });
            }
            
            return examples;
        }

        function displayExamples(examples) {
            const examplesContainer = document.getElementById('examplesContainer');
            const examplesDiv = document.getElementById('examples');
            
            let htmlExamples = '';
            examples.forEach(example => {
                const categoriesText = example.categories.length > 0 ? example.categories.join(' | ') : 'Aucune';
                const translationText = example.translation ? `<br><strong>Traduction IA:</strong> "${example.translation}"` : '';
                
                htmlExamples += `
                    <div class="example-item">
                        <strong>ID:</strong> ${example.id}<br>
                        <strong>R√©ponse:</strong> "${example.response}"<br>
                        <strong>Cat√©gories match√©es:</strong> ${categoriesText}${translationText}
                    </div>
                `;
            });
            
            examplesDiv.innerHTML = htmlExamples;
            examplesContainer.classList.remove('hidden');
        }

        function setupDownloadInterface() {
            const downloadContainer = document.getElementById('downloadContainer');
            const downloadLinks = document.getElementById('downloadLinks');
            
            downloadLinks.innerHTML = `
                <button class="copy-button" onclick="displayTable()">
                    üìã Afficher le tableau
                </button>
                <button class="copy-button" onclick="exportCSV()">
                    üìÑ Exporter CSV
                </button>
                <button class="copy-button" onclick="exportExcel()">
                    üìä Exporter Excel
                </button>
                <button class="copy-button" onclick="copyTableData()">
                    üìé Copier les donn√©es
                </button>
            `;
            
            downloadContainer.classList.remove('hidden');
        }

        function displayTable() {
            const tableContainer = document.getElementById('tableContainer');
            
            if (!processedData || processedData.length === 0) {
                tableContainer.innerHTML = '<p>Aucune donn√©e √† afficher</p>';
                return;
            }

            const columns = Object.keys(processedData[0]);
            let html = `
                <div class="table-container">
                    <table class="data-table">
                        <thead>
                            <tr>
                                ${columns.map(col => `<th>${col}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
            `;

            processedData.forEach(row => {
                html += '<tr>';
                columns.forEach(col => {
                    const value = row[col] || '';
                    html += `<td>${value.toString()}</td>`;
                });
                html += '</tr>';
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            tableContainer.innerHTML = html;
        }

        function exportCSV() {
            if (!processedData || processedData.length === 0) {
                alert('Aucune donn√©e √† exporter');
                return;
            }

            try {
                const columns = Object.keys(processedData[0]);
                let csv = '\uFEFF'; // BOM pour Excel UTF-8
                csv += columns.join(',') + '\n';

                processedData.forEach(row => {
                    const values = columns.map(col => {
                        let value = (row[col] || '').toString();
                        // √âchapper les guillemets et virgules
                        if (value.includes(',') || value.includes('"') || value.includes('\n') || value.includes('\r')) {
                            value = '"' + value.replace(/"/g, '""') + '"';
                        }
                        return value;
                    });
                    csv += values.join(',') + '\n';
                });

                // G√©n√©rer le nom de fichier avec timestamp
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                const filename = `analyse_multi_concepts_${timestamp}.csv`;
                
                downloadFile(csv, filename, 'text/csv;charset=utf-8;');
                updateStatus('‚úÖ Fichier CSV export√© avec succ√®s!', 'success');
                
            } catch (error) {
                console.error('Erreur lors de l\'exportation CSV:', error);
                updateStatus('‚ùå Erreur lors de l\'exportation CSV.', 'error');
            }
        }

        function exportExcel() {
            if (!processedData || processedData.length === 0) {
                alert('Aucune donn√©e √† exporter');
                return;
            }

            try {
                // Cr√©er une copie des donn√©es pour l'export
                const dataForExport = processedData.map(row => {
                    const cleanRow = {};
                    Object.keys(row).forEach(key => {
                        // Nettoyer les donn√©es pour √©viter les erreurs Excel
                        let value = row[key];
                        if (value === null || value === undefined) {
                            cleanRow[key] = '';
                        } else if (typeof value === 'object') {
                            cleanRow[key] = JSON.stringify(value);
                        } else {
                            cleanRow[key] = value.toString();
                        }
                    });
                    return cleanRow;
                });

                // Cr√©er la feuille de calcul
                const ws = XLSX.utils.json_to_sheet(dataForExport);
                
                // D√©finir la largeur des colonnes
                const colWidths = [];
                if (dataForExport.length > 0) {
                    Object.keys(dataForExport[0]).forEach(key => {
                        const maxLength = Math.max(
                            key.length,
                            ...dataForExport.map(row => (row[key] || '').toString().length)
                        );
                        colWidths.push({ wch: Math.min(maxLength + 2, 50) });
                    });
                }
                ws['!cols'] = colWidths;

                // Cr√©er le classeur
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'Analyse Multi-Concepts');
                
                // G√©n√©rer le nom de fichier avec timestamp
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                const filename = `analyse_multi_concepts_${timestamp}.xlsx`;
                
                // T√©l√©charger le fichier
                XLSX.writeFile(wb, filename);
                
                updateStatus('‚úÖ Fichier Excel export√© avec succ√®s!', 'success');
                
            } catch (error) {
                console.error('Erreur lors de l\'exportation Excel:', error);
                updateStatus('‚ùå Erreur lors de l\'exportation Excel. Essayez l\'export CSV.', 'error');
                
                // Fallback vers CSV si Excel √©choue
                setTimeout(() => {
                    if (confirm('L\'export Excel a √©chou√©. Voulez-vous essayer l\'export CSV √† la place ?')) {
                        exportCSV();
                    }
                }, 1000);
            }
        }

        function copyTableData() {
            if (!processedData || processedData.length === 0) return;

            const columns = Object.keys(processedData[0]);
            let text = columns.join('\t') + '\n';

            processedData.forEach(row => {
                const values = columns.map(col => (row[col] || '').toString().replace(/\t/g, ' '));
                text += values.join('\t') + '\n';
            });

            navigator.clipboard.writeText(text).then(() => {
                alert('Donn√©es copi√©es dans le presse-papiers!');
            }).catch(() => {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Donn√©es copi√©es dans le presse-papiers!');
            });
        }

        function downloadFile(content, filename, contentType) {
            try {
                const blob = new Blob([content], { type: contentType });
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                
                // Ajouter au DOM, cliquer, puis supprimer
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Nettoyer l'URL apr√®s un d√©lai
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                }, 1000);
                
            } catch (error) {
                console.error('Erreur lors du t√©l√©chargement:', error);
                
                // Fallback pour navigateurs plus anciens
                try {
                    const textArea = document.createElement('textarea');
                    textArea.value = content;
                    textArea.style.position = 'fixed';
                    textArea.style.opacity = '0';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    alert('Le t√©l√©chargement a √©chou√©, mais les donn√©es ont √©t√© copi√©es dans le presse-papiers.');
                } catch (fallbackError) {
                    console.error('Erreur de fallback:', fallbackError);
                    alert('Erreur lors du t√©l√©chargement. Essayez de copier les donn√©es manuellement.');
                }
            }
        }
    </script>
</body>
</html>
